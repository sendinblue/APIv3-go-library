// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// UpdateEmailCampaign update email campaign
// swagger:model updateEmailCampaign
type UpdateEmailCampaign struct {

	// Absolute url of the attachment. Url not allowed from local machine. File must be hosted somewhere.Possilbe extension values are xlsx, xls, ods, docx, docm, doc, csv, pdf, txt, gif, jpg, jpeg, png, tif, tiff and rtf
	AttachmentURL string `json:"attachmentUrl,omitempty"`

	// Footer of the email campaign
	Footer string `json:"footer,omitempty"`

	// Header of the email campaign
	Header string `json:"header,omitempty"`

	// Body of the message (HTML version). REQUIRED if htmlUrl is empty
	HTMLContent string `json:"htmlContent,omitempty"`

	// Url which contents the body of the email message. REQUIRED if htmlContent is empty
	HTMLURL string `json:"htmlUrl,omitempty"`

	// Status of inline image. inlineImageActivation = false means image can’t be embedded, & inlineImageActivation = true means image can be embedded, in the email. You cannot send a campaign of more than 4MB with images embedded in the email. Campaigns with the images embedded in the email must be sent to less than 5000 contacts.
	InlineImageActivation *bool `json:"inlineImageActivation,omitempty"`

	// Status of mirror links in campaign. mirrorActive = false means mirror links are deactivated, & mirrorActive = true means mirror links are activated, in the campaign
	MirrorActive bool `json:"mirrorActive,omitempty"`

	// Name of the campaign
	Name string `json:"name,omitempty"`

	// recipients
	Recipients *UpdateEmailCampaignRecipients `json:"recipients,omitempty"`

	// FOR TRIGGER ONLY ! Type of trigger campaign.recurring = false means contact can receive the same Trigger campaign only once, & recurring = true means contact can receive the same Trigger campaign several times
	Recurring *bool `json:"recurring,omitempty"`

	// Email on which campaign recipients will be able to reply to
	ReplyTo strfmt.Email `json:"replyTo,omitempty"`

	// Date and time on which the campaign has to run (YYYY-MM-DDTHH:mm:ss.SSSZ)
	ScheduledAt strfmt.DateTime `json:"scheduledAt,omitempty"`

	// sender
	Sender *UpdateEmailCampaignSender `json:"sender,omitempty"`

	// Subject of the campaign
	Subject string `json:"subject,omitempty"`

	// Tag of the campaign
	Tag string `json:"tag,omitempty"`

	// This is to personalize the «To» Field. If you want to include the first name and last name of your recipient, add [FNAME] [LNAME]. To use the contact attributes here, these must already exist in SendinBlue account
	ToField string `json:"toField,omitempty"`

	// Customize the utm_campaign value. If this field is empty, the campaign name will be used. Only alphanumeric characters and spaces are allowed
	UtmCampaign string `json:"utmCampaign,omitempty"`
}

// Validate validates this update email campaign
func (m *UpdateEmailCampaign) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateRecipients(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSender(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *UpdateEmailCampaign) validateRecipients(formats strfmt.Registry) error {

	if swag.IsZero(m.Recipients) { // not required
		return nil
	}

	if m.Recipients != nil {

		if err := m.Recipients.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("recipients")
			}
			return err
		}
	}

	return nil
}

func (m *UpdateEmailCampaign) validateSender(formats strfmt.Registry) error {

	if swag.IsZero(m.Sender) { // not required
		return nil
	}

	if m.Sender != nil {

		if err := m.Sender.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("sender")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *UpdateEmailCampaign) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *UpdateEmailCampaign) UnmarshalBinary(b []byte) error {
	var res UpdateEmailCampaign
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
